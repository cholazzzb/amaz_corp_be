// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: postgresql.sql

package locationpostgres

import (
	"context"
	"database/sql"
)

const createMemberBuilding = `-- name: CreateMemberBuilding :execresult
INSERT INTO members_buildings(member_id, building_id)
VALUES ($1, $2)
`

type CreateMemberBuildingParams struct {
	MemberID   string
	BuildingID string
}

func (q *Queries) CreateMemberBuilding(ctx context.Context, arg CreateMemberBuildingParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMemberBuilding, arg.MemberID, arg.BuildingID)
}

const deleteMemberBuilding = `-- name: DeleteMemberBuilding :exec
DELETE FROM members_buildings
WHERE member_id = $1 AND building_id = $2
`

type DeleteMemberBuildingParams struct {
	MemberID   string
	BuildingID string
}

func (q *Queries) DeleteMemberBuilding(ctx context.Context, arg DeleteMemberBuildingParams) error {
	_, err := q.db.ExecContext(ctx, deleteMemberBuilding, arg.MemberID, arg.BuildingID)
	return err
}

const getAllBuildings = `-- name: GetAllBuildings :many
SELECT id, name
FROM buildings
LIMIT 10
`

func (q *Queries) GetAllBuildings(ctx context.Context) ([]Building, error) {
	rows, err := q.db.QueryContext(ctx, getAllBuildings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Building
	for rows.Next() {
		var i Building
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingsByMemberId = `-- name: GetBuildingsByMemberId :many
SELECT b.id, b.name
FROM buildings b
JOIN members_buildings mb ON (b.id = mb.building_id)
WHERE mb.member_id = $1
LIMIT 10
`

func (q *Queries) GetBuildingsByMemberId(ctx context.Context, memberID string) ([]Building, error) {
	rows, err := q.db.QueryContext(ctx, getBuildingsByMemberId, memberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Building
	for rows.Next() {
		var i Building
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListMemberByBuildingID = `-- name: GetListMemberByBuildingID :many
SELECT members.id, members.name, members.status
FROM members
INNER JOIN members_buildings
ON members.id = members_buildings.member_id
WHERE members_buildings.building_id = $1
LIMIT 20
`

type GetListMemberByBuildingIDRow struct {
	ID     string
	Name   string
	Status string
}

func (q *Queries) GetListMemberByBuildingID(ctx context.Context, buildingID string) ([]GetListMemberByBuildingIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getListMemberByBuildingID, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListMemberByBuildingIDRow
	for rows.Next() {
		var i GetListMemberByBuildingIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberBuildingById = `-- name: GetMemberBuildingById :one
SELECT EXISTS(SELECT mb.member_id, mb.building_id 
FROM members_buildings mb
WHERE mb.member_id = $1 AND mb.building_id = $2
LIMIT 1)
`

type GetMemberBuildingByIdParams struct {
	MemberID   string
	BuildingID string
}

func (q *Queries) GetMemberBuildingById(ctx context.Context, arg GetMemberBuildingByIdParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getMemberBuildingById, arg.MemberID, arg.BuildingID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getMembersByRoomId = `-- name: GetMembersByRoomId :many
SELECT m.name, m.status, m.user_id
FROM members m
WHERE m.room_id = $1
LIMIT 10
`

type GetMembersByRoomIdRow struct {
	Name   string
	Status string
	UserID string
}

func (q *Queries) GetMembersByRoomId(ctx context.Context, roomID sql.NullString) ([]GetMembersByRoomIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getMembersByRoomId, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMembersByRoomIdRow
	for rows.Next() {
		var i GetMembersByRoomIdRow
		if err := rows.Scan(&i.Name, &i.Status, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsByBuildingId = `-- name: GetRoomsByBuildingId :many
SELECT r.id, r.name
FROM rooms r
WHERE r.building_id = $1
LIMIT 10
`

type GetRoomsByBuildingIdRow struct {
	ID   string
	Name string
}

func (q *Queries) GetRoomsByBuildingId(ctx context.Context, buildingID string) ([]GetRoomsByBuildingIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoomsByBuildingId, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomsByBuildingIdRow
	for rows.Next() {
		var i GetRoomsByBuildingIdRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsByMemberId = `-- name: GetRoomsByMemberId :many
SELECT r.id, r.name
FROM rooms r
JOIN members_buildings mb ON (mb.building_id = r.building_id)
WHERE mb.member_id = $1
LIMIT 10
`

type GetRoomsByMemberIdRow struct {
	ID   string
	Name string
}

func (q *Queries) GetRoomsByMemberId(ctx context.Context, memberID string) ([]GetRoomsByMemberIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoomsByMemberId, memberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomsByMemberIdRow
	for rows.Next() {
		var i GetRoomsByMemberIdRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
