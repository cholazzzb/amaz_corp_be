// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: postgresql.sql

package locationpostgres

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createFriend = `-- name: CreateFriend :execresult
INSERT INTO friends(member1_id, member2_id)
VALUES ($1, $2)
`

type CreateFriendParams struct {
	Member1ID uuid.UUID
	Member2ID uuid.UUID
}

func (q *Queries) CreateFriend(ctx context.Context, arg CreateFriendParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createFriend, arg.Member1ID, arg.Member2ID)
}

const createMember = `-- name: CreateMember :one
INSERT INTO members(name, status, user_id)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateMemberParams struct {
	Name   string
	Status string
	UserID string
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createMember, arg.Name, arg.Status, arg.UserID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createMemberBuilding = `-- name: CreateMemberBuilding :execresult
INSERT INTO members_buildings(member_id, building_id)
VALUES ($1, $2)
`

type CreateMemberBuildingParams struct {
	MemberID   uuid.UUID
	BuildingID uuid.UUID
}

func (q *Queries) CreateMemberBuilding(ctx context.Context, arg CreateMemberBuildingParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMemberBuilding, arg.MemberID, arg.BuildingID)
}

const deleteMemberBuilding = `-- name: DeleteMemberBuilding :exec
DELETE FROM members_buildings
WHERE member_id = $1 AND building_id = $2
`

type DeleteMemberBuildingParams struct {
	MemberID   uuid.UUID
	BuildingID uuid.UUID
}

func (q *Queries) DeleteMemberBuilding(ctx context.Context, arg DeleteMemberBuildingParams) error {
	_, err := q.db.ExecContext(ctx, deleteMemberBuilding, arg.MemberID, arg.BuildingID)
	return err
}

const getAllBuildings = `-- name: GetAllBuildings :many
SELECT id, name
FROM buildings
LIMIT 10
`

func (q *Queries) GetAllBuildings(ctx context.Context) ([]Building, error) {
	rows, err := q.db.QueryContext(ctx, getAllBuildings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Building
	for rows.Next() {
		var i Building
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingsByUserID = `-- name: GetBuildingsByUserID :many
SELECT b.id, b.name
FROM members
INNER JOIN members_buildings
ON members.id = members_buildings.member_id
INNER JOIN buildings b
ON b.id = members_buildings.building_id
INNER JOIN users
ON users.id = members.user_id
WHERE users.id = $1
LIMIT 10
`

func (q *Queries) GetBuildingsByUserID(ctx context.Context, id string) ([]Building, error) {
	rows, err := q.db.QueryContext(ctx, getBuildingsByUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Building
	for rows.Next() {
		var i Building
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendsByMemberId = `-- name: GetFriendsByMemberId :many
SELECT m.id, m.name, m.status
FROM members m
JOIN friends f ON (m.id = f.member1_id OR m.id = f.member2_id)
WHERE (f.member1_id = $1 OR f.member2_id = $1) AND m.id != $1
LIMIT 10
`

type GetFriendsByMemberIdRow struct {
	ID     uuid.UUID
	Name   string
	Status string
}

func (q *Queries) GetFriendsByMemberId(ctx context.Context, member1ID uuid.UUID) ([]GetFriendsByMemberIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getFriendsByMemberId, member1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsByMemberIdRow
	for rows.Next() {
		var i GetFriendsByMemberIdRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListMemberByBuildingID = `-- name: GetListMemberByBuildingID :many
SELECT members.id, members.name, members.status
FROM members
INNER JOIN members_buildings
ON members.id = members_buildings.member_id
WHERE members_buildings.building_id = $1
LIMIT 20
`

type GetListMemberByBuildingIDRow struct {
	ID     uuid.UUID
	Name   string
	Status string
}

func (q *Queries) GetListMemberByBuildingID(ctx context.Context, buildingID uuid.UUID) ([]GetListMemberByBuildingIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getListMemberByBuildingID, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListMemberByBuildingIDRow
	for rows.Next() {
		var i GetListMemberByBuildingIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberBuildingById = `-- name: GetMemberBuildingById :one
SELECT EXISTS(
    SELECT mb.member_id, mb.building_id 
    FROM members_buildings mb
    WHERE mb.member_id = $1 AND mb.building_id = $2
    LIMIT 1
)
`

type GetMemberBuildingByIdParams struct {
	MemberID   uuid.UUID
	BuildingID uuid.UUID
}

func (q *Queries) GetMemberBuildingById(ctx context.Context, arg GetMemberBuildingByIdParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getMemberBuildingById, arg.MemberID, arg.BuildingID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getMemberByID = `-- name: GetMemberByID :one
SELECT id, user_id, name, status, room_id
FROM members
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetMemberByID(ctx context.Context, id uuid.UUID) (Member, error) {
	row := q.db.QueryRowContext(ctx, getMemberByID, id)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Status,
		&i.RoomID,
	)
	return i, err
}

const getMemberByName = `-- name: GetMemberByName :one
SELECT id, user_id, name, status, room_id
FROM members
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetMemberByName(ctx context.Context, name string) (Member, error) {
	row := q.db.QueryRowContext(ctx, getMemberByName, name)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Status,
		&i.RoomID,
	)
	return i, err
}

const getMembersByRoomId = `-- name: GetMembersByRoomId :many
SELECT m.name, m.status, m.user_id
FROM members m
WHERE m.room_id = $1
LIMIT 10
`

type GetMembersByRoomIdRow struct {
	Name   string
	Status string
	UserID string
}

func (q *Queries) GetMembersByRoomId(ctx context.Context, roomID uuid.NullUUID) ([]GetMembersByRoomIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getMembersByRoomId, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMembersByRoomIdRow
	for rows.Next() {
		var i GetMembersByRoomIdRow
		if err := rows.Scan(&i.Name, &i.Status, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsByBuildingId = `-- name: GetRoomsByBuildingId :many
SELECT r.id, r.name
FROM rooms r
WHERE r.building_id = $1
LIMIT 10
`

type GetRoomsByBuildingIdRow struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) GetRoomsByBuildingId(ctx context.Context, buildingID uuid.UUID) ([]GetRoomsByBuildingIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoomsByBuildingId, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomsByBuildingIdRow
	for rows.Next() {
		var i GetRoomsByBuildingIdRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsByMemberId = `-- name: GetRoomsByMemberId :many
SELECT r.id, r.name
FROM rooms r
JOIN members_buildings mb ON (mb.building_id = r.building_id)
WHERE mb.member_id = $1
LIMIT 10
`

type GetRoomsByMemberIdRow struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) GetRoomsByMemberId(ctx context.Context, memberID uuid.UUID) ([]GetRoomsByMemberIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoomsByMemberId, memberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomsByMemberIdRow
	for rows.Next() {
		var i GetRoomsByMemberIdRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBuildingExist = `-- name: GetUserBuildingExist :one
SELECT EXISTS(
    SELECT users.id, username, password, salt, members.id, user_id, name, status, room_id, member_id, building_id 
    FROM users
    INNER JOIN members
    ON users.id = members.user_id
    INNER JOIN members_buildings
    ON members_buildings.member_id = members.id
    WHERE users.id = $1 AND members_buildings.building_id = $2
    LIMIT 1
)
`

type GetUserBuildingExistParams struct {
	ID         string
	BuildingID uuid.UUID
}

func (q *Queries) GetUserBuildingExist(ctx context.Context, arg GetUserBuildingExistParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getUserBuildingExist, arg.ID, arg.BuildingID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
