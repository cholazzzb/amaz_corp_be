// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: postgresql.sql

package schedulepostgres

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createScheduleByRoomID = `-- name: CreateScheduleByRoomID :one
INSERT INTO schedules(room_id)
VALUES($1)
RETURNING room_id
`

func (q *Queries) CreateScheduleByRoomID(ctx context.Context, roomID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createScheduleByRoomID, roomID)
	var room_id uuid.UUID
	err := row.Scan(&room_id)
	return room_id, err
}

const createTask = `-- name: CreateTask :execresult
INSERT INTO tasks(schedule_id, start_time, end_time, task_detail_id)
VALUES ($1, $2, $3, $4)
`

type CreateTaskParams struct {
	ScheduleID   uuid.UUID
	StartTime    sql.NullTime
	EndTime      sql.NullTime
	TaskDetailID uuid.UUID
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTask,
		arg.ScheduleID,
		arg.StartTime,
		arg.EndTime,
		arg.TaskDetailID,
	)
}

const createTaskDetail = `-- name: CreateTaskDetail :one
INSERT INTO task_details(name, owner_id, assignee_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateTaskDetailParams struct {
	Name       sql.NullString
	OwnerID    uuid.NullUUID
	AssigneeID uuid.NullUUID
	Status     sql.NullString
}

func (q *Queries) CreateTaskDetail(ctx context.Context, arg CreateTaskDetailParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createTaskDetail,
		arg.Name,
		arg.OwnerID,
		arg.AssigneeID,
		arg.Status,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const editTask = `-- name: EditTask :execresult
UPDATE tasks
SET start_time = $2,
    end_time = $3,
    task_detail_id = $4
WHERE id = $1
`

type EditTaskParams struct {
	ID           uuid.UUID
	StartTime    sql.NullTime
	EndTime      sql.NullTime
	TaskDetailID uuid.UUID
}

func (q *Queries) EditTask(ctx context.Context, arg EditTaskParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, editTask,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.TaskDetailID,
	)
}

const getListTaskAndDetailByScheduleID = `-- name: GetListTaskAndDetailByScheduleID :many
SELECT tasks.id,
	   tasks.schedule_id,
	   tasks.start_time,
	   tasks.end_time,
	   tasks.task_detail_id,
	   task_details.name,
	   task_details.owner_id,
	   task_details.assignee_id,
	   task_details.status,
	   ARRAY_AGG (TD.depended_task_id)
FROM tasks
INNER JOIN task_details 
ON tasks.task_detail_id = task_details.id
FULL OUTER JOIN tasks_dependencies TD
ON TD.task_id = tasks.id
WHERE tasks.schedule_id = $1
	AND tasks.start_time = $2
	AND tasks.end_time = $3
	AND task_details.owner_id = $4
	AND task_details.assignee_id = $5
GROUP BY tasks.id
LIMIT 100
`

type GetListTaskAndDetailByScheduleIDParams struct {
	ScheduleID uuid.UUID
	StartTime  sql.NullTime
	EndTime    sql.NullTime
	OwnerID    uuid.NullUUID
	AssigneeID uuid.NullUUID
}

type GetListTaskAndDetailByScheduleIDRow struct {
	ID           uuid.UUID
	ScheduleID   uuid.UUID
	StartTime    sql.NullTime
	EndTime      sql.NullTime
	TaskDetailID uuid.UUID
	Name         sql.NullString
	OwnerID      uuid.NullUUID
	AssigneeID   uuid.NullUUID
	Status       sql.NullString
	ArrayAgg     interface{}
}

func (q *Queries) GetListTaskAndDetailByScheduleID(ctx context.Context, arg GetListTaskAndDetailByScheduleIDParams) ([]GetListTaskAndDetailByScheduleIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getListTaskAndDetailByScheduleID,
		arg.ScheduleID,
		arg.StartTime,
		arg.EndTime,
		arg.OwnerID,
		arg.AssigneeID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListTaskAndDetailByScheduleIDRow
	for rows.Next() {
		var i GetListTaskAndDetailByScheduleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.StartTime,
			&i.EndTime,
			&i.TaskDetailID,
			&i.Name,
			&i.OwnerID,
			&i.AssigneeID,
			&i.Status,
			&i.ArrayAgg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTaskByScheduleID = `-- name: GetListTaskByScheduleID :many
SELECT id, schedule_id, start_time, end_time, task_detail_id
FROM tasks
WHERE tasks.schedule_id = $1
	AND (tasks.start_time >= $2 OR $2 IS NULL) 
	AND (tasks.end_time <= $3 OR tasks.end_time <= $3 + interval '1 day' OR $3 IS NULL)
LIMIT 100
`

type GetListTaskByScheduleIDParams struct {
	ScheduleID uuid.UUID
	StartTime  sql.NullTime
	EndTime    sql.NullTime
}

func (q *Queries) GetListTaskByScheduleID(ctx context.Context, arg GetListTaskByScheduleIDParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getListTaskByScheduleID, arg.ScheduleID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.StartTime,
			&i.EndTime,
			&i.TaskDetailID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleIdByRoomID = `-- name: GetScheduleIdByRoomID :one
SELECT id, room_id 
FROM schedules
WHERE schedules.room_id = $1
LIMIT 1
`

func (q *Queries) GetScheduleIdByRoomID(ctx context.Context, roomID uuid.UUID) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, getScheduleIdByRoomID, roomID)
	var i Schedule
	err := row.Scan(&i.ID, &i.RoomID)
	return i, err
}

const getTaskDetailByID = `-- name: GetTaskDetailByID :one
SELECT id, name, owner_id, assignee_id, status
FROM task_details
WHERE task_details.id = $1
LIMIT 1
`

func (q *Queries) GetTaskDetailByID(ctx context.Context, id uuid.UUID) (TaskDetail, error) {
	row := q.db.QueryRowContext(ctx, getTaskDetailByID, id)
	var i TaskDetail
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.AssigneeID,
		&i.Status,
	)
	return i, err
}
